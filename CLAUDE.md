# Claude Prompt Context Guide (for Claude LLM)

This file provides architectural, stylistic, and domain-level constraints for assisting with development in a monorepo project using **Next.js** (frontend) and **NestJS** (backend).  
It defines our code organization strategy, design principles, naming conventions, and SOLID-driven service design patterns.

---

## 🔧 Project Structure Overview

We use a **Turborepo-based monorepo** layout:

```
.
├── apps/
│   ├── web/        # Next.js frontend (App Router)
│   └── api/        # NestJS backend
├── packages/
│   ├── types/      # Shared TypeScript types (DTOs, entities)
│   └── utils/      # Shared utilities
├── Claude.md       # Claude instruction context
└── turbo.json
```

---

## 🧠 Architectural Principles

This project follows the **SOLID** principles to ensure high cohesion, loose coupling, and scalable design.

### ✅ S - Single Responsibility Principle
- Each module, class, and function must have only one reason to change.
- Controllers only receive HTTP requests and delegate logic to services or use-cases.

### ✅ O - Open/Closed Principle
- New features should be added via extension (new files/classes) rather than modifying core logic.
- Abstract interfaces and plugin-style service layers are encouraged.

### ✅ L - Liskov Substitution Principle
- Services should rely on abstractions (e.g., interfaces), so alternate implementations (e.g., mock, production) are interchangeable.

### ✅ I - Interface Segregation Principle
- Small, task-specific interfaces are preferred over large, generic ones.
- One use-case = one interface contract.

### ✅ D - Dependency Inversion Principle
- High-level modules should not depend on low-level modules.
- We use NestJS dependency injection to bind interfaces to implementations.

---

## 📦 Backend (NestJS)

- Controllers handle HTTP logic only.
- Services encapsulate business logic.
- Use-cases encapsulate one domain-specific action (ex: CreateUserUseCase).
- DTOs are placed under `src/modules/[feature]/dto/`
- All public API routes are documented via Swagger decorators.

```ts
@Controller('users')
export class UsersController {
  constructor(private readonly userService: UserService) {}

  @Post()
  create(@Body() dto: CreateUserDto) {
    return this.userService.create(dto);
  }
}
```

---

## 💻 Frontend (Next.js)

- Uses App Router and Server Components where possible.
- Each feature is encapsulated under `/features/[name]`
- API client and hooks are colocated with features (generated by `orval` or typed with `openapi-typescript`).
- Shared design system components are in `/components`

---

## 📐 Shared Types & API Models

Shared DTOs, enums, and interfaces are stored under:

```
packages/types/src/
├── dto/
├── api/
└── entities/
```

All API contracts used on the frontend should be imported from this package to avoid duplication.

---

## ✅ Rules for Claude

When assisting with development, follow these rules:

1. Follow **SOLID** principles in architectural design and example code.
2. Separate responsibilities clearly: controller ≠ service ≠ use-case.
3. Avoid any business logic in the controller.
4. Use dependency injection (DI) where possible.
5. If API or DTOs are referenced, assume they live under `packages/types`.
6. When defining new functionality, suggest both backend and frontend changes if applicable.
7. TypeScript is required on both frontend and backend.
8. If generating code, prefer clean, functional, composable style.

---

## 🧪 Testing & Validation

- Backend: Use Jest for unit and e2e tests.
- Frontend: Use Jest + React Testing Library.
- DTOs should use `class-validator` decorators for runtime validation.

---

## 🔗 Tools & Libraries

| Tool | Purpose |
|------|---------|
| Turborepo | Monorepo management |
| Swagger (NestJS) | API documentation and contract |
| openapi-typescript | Type generation from OpenAPI |
| orval | Type + API client generator |
| class-validator | DTO validation on server |
| react-hook-form | Form handling on frontend |
| zod (optional) | Schema validation on frontend |

---

## 🤝 Collaboration Notes

- All new modules/features should follow domain-driven structure.
- Commit messages use conventional commits.
- PRs must describe purpose, feature area, and affected modules.

---

## 📌 Final Note to Claude

If asked to generate or explain code, please assume:
- **Modular, scalable, maintainable** architecture is expected
- Always **justify design decisions**
- You are contributing as a **senior developer in a scalable system**